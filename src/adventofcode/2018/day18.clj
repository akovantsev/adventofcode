(ns adventofcode.2018.day18
  (:require [clojure.string :as str]
            [clojure.set :as set]
            [adventofcode.utils :as u]))

(def input "..|..|.|.|.||..#.#|...|..#.|.........|.......|..#.\n#.|.........|||....#....|....##||.....|.|.........\n..||......#.#||#.#.......#..#.#.###...|.#..#...#..\n|....#....|.##.##.....##...##|..|....|..|#||...###\n#|...|.#|..|......#.##....#|....|...|#......|.#|.|\n..|....##.##.#..||##...#..##|......|...|#.||.#.#..\n.#...#||...........#|.....|##....#.#...|#.|###..|.\n||....#.#.|...||...###|.|#.....#.|#.|#...#.#.|...#\n...#.....||.......#....#|###|####..|#|.###..||.#.#\n|#|...||..##.||.||..#.#.|..#...#..|........#..|#..\n#....||.|.....|.|.#|.##.|..|.#.....|..|.....#|.|..\n|..||#........|#.|..|.|...#..#....#.|.....||#.#...\n..|...||.|##||##..|...#|.....|#.|....#....||#.##..\n#|..#|..||...|..|.|#|..##.#.......#|#....#||...#..\n|#|.|...|..##...|.#||#..#...#....||.#.|...##..|..#\n|..||.#.#..|....#...#.#..#..#...||.|.#.#.#.....#|.\n.|##.####..||.#.|#.###....#...#.|..#.#.##.|..##..#\n#|.......#......|.#..|.....||.|.#||#.#.##.#|....|.\n.|..#.|#.##|....#......|.#||..|#..##.|..#......###\n..###....#.||.#..|##.##..#|.#...|#|...#.|.|...#|#.\n........||......|##||##..###|..|.##.#..#|##...|..#\n.#....|....|...##.#.||##.....#|...|#.#||...#.....|\n#...#|...###.|.|..|..#.|###.|.#.|.####|...|.#..|#.\n...#..|.....|.#.##.|.#.#..|..##.##.#..|...#...|#..\n..###.#|##|#.#.......|.|...||###|.#.........#..|..\n..|#...||.#.#..|...|..#||...|.#.#......#...|..#...\n.||..........|.#....|.||...|#.|.|||..||........|#.\n#.##.#||..|.|#...|..#|.|#......|.||.......|...|#..\n#.||.||#...#|||.....|.|.|.|...||.#..#.#.#|..|||.|.\n.#...#...||||#...##.#.#......#|......#.|.....|#||.\n.#|.###|#||.|#...#.|..|.|#.|#..#..#...|.|.|...|.|.\n..#|.|#|..##|.||.|.....|#...#..|.|#....|.|..|..|#.\n#....|..#.#.......#||..#....|.|..#.#|..#...|#.#.|.\n#.#.|..|...#|.###||.#.....#|#|#.##..|.|#|....|....\n....|#.#.||..|..#...|...|..|...|..#..#......#|.#..\n..#..#|.|.|#.#.|.|.#.#.....#..|..#..|.......||#|#.\n#|......|#..|.#...##|....|..|#||..|..||...||.#....\n#..|#.......||.....|.||||#.|#.|....#|#....|#.#....\n#.##.#.#..||......#...|......|#|...|.||.#.|..|....\n####.|...||##|#|.......|||.#.#.....#...##.#|..#...\n..|..|||..|.||#|#.|..#.|..#.|........###......#..|\n..#|.....|||||#..||.....##..#...|||.....#......#.#\n.#.|.||#.##.......||.#.||..#...|##..|.#.#...|...|.\n.##........|..||.|.#|.|.||||..#...#..|..|#|#..|#|.\n.#.#.....#|||..|...#.|...|...#.||..||###|.#|......\n|.|#..#.#.|||||.#|.|......#.|#.||.....#..#...|#.|.\n...|....#.###|.#.##......|#.##.....#.|.##.#......#\n.#.#.....|..#.##..#|#|..#.#|##..##|..##.#..#....||\n..#.#.|.....#.|..#.|.|#...|....#...|..|.|..#||...|\n|.||.|...|...|##..||....|#.|..#..##....|#.#|##..|.")
;(def input ".#.#...|#.\n.....#|##|\n.|..|...#.\n..|#.....#\n#.#|||#|#|\n...#.||...\n.|....|...\n||...#|.#|\n|.||||..|.\n...#.|..|.")


(def FOREST
  (->> input (str/split-lines) (mapv vec)))

(def XMIN 0)
(def YMIN 0)
(def XMAX (-> FOREST first count dec))
(def YMAX (-> FOREST count dec))

(def ALL-XYS
  (for [x (range XMIN (inc YMAX))
        y (range YMIN (inc YMAX))]
    [x y]))


(def adjacent-xys
  (memoize
    (fn -adjacent-xys [[x1 y1]]
      (let [x0 (dec x1) x2 (inc x1)
            y0 (dec y1) y2 (inc y1)
            adjacent #{[x0 y0] [x1 y0] [x2 y0]
                       [x0 y1] ,,,,,,, [x2 y1]
                       [x0 y2] [x1 y2] [x2 y2]}
            x first
            y second]
        (->> adjacent
          (filter #(<= XMIN (x %) XMAX))
          (filter #(<= YMIN (y %) YMAX)))))))


(def change
  (memoize
    (fn -change [v adjacent]
      (let [amount (merge
                     {\. 0  \| 0  \# 0}
                     (frequencies adjacent))]
        (case v
          \. (if (-> \| amount (> 2)) \| \.)
          \| (if (-> \# amount (> 2)) \# \|)
          \# (if (and
                   (-> \# amount (> 0))
                   (-> \| amount (> 0))) \# \.))))))


(defn tick [forest]
  (->> ALL-XYS
    (reduce
      (fn rf [vv xy]
        (let [neighbors (->> xy adjacent-xys (map #(get-in forest %)))]
          (update-in vv xy change neighbors)))
      forest)))

(defn score [forest]
  (let [stats (->> forest (reduce concat []) (frequencies))]
    (* (get stats \| 0)
       (get stats \# 0))))



(defn simulate [iterations-limit]
  (time
    (loop [minute 0
           forest FOREST
           seen   {}]
      (if (= minute iterations-limit)
        (score forest)
        (let [forest'   (tick forest)
              seen-time (get seen forest')]
          (if seen-time
            (let [period   (- minute seen-time)
                  periodic (- iterations-limit seen-time)
                  skip-to  (- iterations-limit (rem periodic period))]
              (recur (inc skip-to) forest' seen))
            (recur (inc minute) forest' (assoc seen forest' minute))))))))


(assert (= 481290 (simulate 10)))
(assert (= 180752 (simulate 1000000000)))
