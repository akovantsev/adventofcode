(ns adventofcode.2019.day18
  (:require [clojure.string :as str]
            [com.akovantsev.blet.core :refer [blet blet!]]
            [adventofcode.utils :as u]
            [clojure.set :as set]))

(def test0 "########################\n#f.D.E.e.C.b.A.@.a.B.c.#\n######################.#\n#d.....................#\n########################")
(def test1 "########################\n#...............b.C.D.f#\n#.######################\n#.....@.a.B.c.d.A.e.F.g#\n########################")
(def test2 "#################\n#i.G..c...e..H.p#\n########.########\n#j.A..b...f..D.o#\n########@########\n#k.E..a...g..B.n#\n########.########\n#l.F..d...h..C.m#\n#################")
(def test3 "########################\n#@..............ac.GI.b#\n###d#e#f################\n###A#B#C################\n###g#h#i################\n########################")
(def input "#################################################################################\n#........h#..........t..#...#.#e........#.............#.....#....g..#...........#\n#.#######.#.#####.#####.#.#.#.#.#.#####.#.###########.#.#.###.#####.#.#.#.#####.#\n#.#.....#.#.#.#...#.#...#.#.#...#.#.#...#...#.....#...#.#.....#..l#...#.#.#...#.#\n#.#.###.#.#.#.#.###.#.###.#.#####.#.#.###.#.#.###.###.#####.###.#.#####.###.#.#.#\n#.#.#.#.#.....#.#.........#.......#...#.#.#.#.#.#...#.....#...#.#.....#.....#.#.#\n#.#.#.#.#######.###################.###.#.#.#.#.###.#####.###.#.#####.#######.#.#\n#.#.#.#...#...#.........#.....#...#.#...#.#.......#.#.....#...#.#...#...#.....#.#\n###I#.###.#.#.#########.#.###.#.#.#.#.#.#########.#.#####.#.###.#.#.###.#.#####.#\n#...#...#.#.#.........#.#.#.#...#...#.#.#.....#...#.....#.#.#...#.#...#...#...#.#\n#.###.#.#.#.#########.#.#.#.#########.#.#Q###.#.#######.#.###.#######.#######.#.#\n#...#.#.....#...#.......#.#...........#.#.#...#.....#...#.....#.....#.........#.#\n###.#########.#.#########.#####.###.###.#.#.#########.#######.#.###.###.###.###.#\n#...#...#...#.#.........#.....#.#...#...#.#.........#.#...#...#.#.#...#.#.#.#...#\n#.###.#.#.#.#.#########.#####.#.#.#####.#.#########.#.#.#.#.###.#.###.#.#.#.#.###\n#.....#...#.#...#.....#...#.#.#.#.#...#.#...#.....#...#.#.#.#...#.....#...#...#.#\n#.#########.###.#.#######.#.#.#.#.#.#.#.#.#.#.#########.###.#.#.#####.###.#####.#\n#.#.....#.#.#.....#.......#...#.#...#.#.#.#.#.........#.....#.#.#...#.#.......#.#\n#Z#.#.#.#.#.#.#####.#######.###C#####.#.###.#.#######.#.#####.###.#.#.#######.#.#\n#.#.#.#...#.....#.D.#.....#.#.......#.#.#...#.#...#.#...#...#...#.#.#.....#...#.#\n#.###.###.#######.###S###.#.#########.###.###.#.#.#.#####.#####.#.#.#####.###.#.#\n#.#..u#...#j#...#...#.#...#.........#...#.#.#...#...#.......#.#...#.....#...#.#.#\n#.#.###.###.#.#.#.#.###.###########.###.#.#.#######.#######.#.#.#######.###.#.#.#\n#...#.......#r#.#.#...#...#.......#.....#.#...#...#.........#.#.......#.#.#.#...#\n#.#####.#####.#.#.#.#.###.#.###.#.#####.#.###.#.#.###.#######.#########.#.#.###.#\n#.#...#.#...#.#.#.#.#...#.#...#.#.#.....#...#...#.....#.....#...........#...#...#\n###.#.###.#.#.#.###.#####.###.#.###.#####.#.#####.#####.###.#############.#####.#\n#...#.....#...#...W.#...#s..#.#.....#...#.#.....#.#.....#..y..#.....#.....#...#.#\n#F#################.#.#.###.#.#######.#.#.#####.###.#####.###.#.###.#.#####.#.#.#\n#.........#.........#.#.B...#...#...#.#.#.....#.....#.#...#...#.#.#.#.......#.#.#\n#####.###.###########.#########.#.#.#.#.#####.#######.#.#######.#.#.#########.###\n#...#..v#...#.........#.......#...#.#.#.#.....#a......#...........#.#.....#.#...#\n#.#.#######.#.#########.#####.#####.#.#.#.###########.#############.#.#.#.#.###.#\n#.#.........#.#...#...#.....#.#...#.#.#.#.......#.....#..m......#...#.#.#...#...#\n#.###########.#.#.###.#####.#.#.#.#.#.#########.#.###.#.#######.#.#.#.#.#####.###\n#p....#n......#.#.........#.#...#...#...#.....#...#...#.#.......#.#.#.#x#.....#.#\n#.###.#.#######.#########.#.#########.#.#.#.#.#####.#####.#####.#.###.#.#.#####.#\n#.#.#.#.#.....#.....O...#.#.#.......#.#.#.#.#...#...#...#...#.#.#.#...#...#.....#\n#.#.#.#.#.#####.#######.###.#####.#.###.#.#.#####.###.#.###.#.#.#.#.#########.#.#\n#...#...#.............#...........#.......#..o........#.....#...#.............#.#\n#######################################.@.#######################################\n#q......M.............#.....#.....#.#.........#...#..w..........#.#.....#.......#\n#######.#####.#######.#.#.#.#.###.#.#.#.#.###.###.#.###########.#.#.#.#.#####.#.#\n#.....#...#...#.....#.#.#.#.#.#.#.#...#.#...#.....#...#...#...#.#...#.#...J...#.#\n#.###.#####.###.#####.#.#.#.#.#.#.#####.###.#####.###.#.#.#.#.#.#####.#########.#\n#.#.#.#.....#.......#.#.#.#...#.#.......#...#.#...#.#...#...#.#.......#.....#.#.#\n#.#.#.#.###########.#.###.#####.#######.#.###.#.###.#########.#######.#.###V#.#.#\n#.#...#.#...........#.....#.......#.....#.#...#.#.....#.#.R...#...#.#.#.#...#.#.#\n#.#.###.#.###.#####.#######.###.#.#.#####.#.###.#.###.#.#.###.#.#.#.#.#.#.###U#.#\n#.#.....#...#...#.#.#.......#.#.#.#.#...#.#...#...#.#.#.#...#.#.#.#..d#.#...#...#\n#.#########.###.#.#.#.#######.#.#.#.###.#.#.#.#####.#.#.###.###.#.#####.###.#.###\n#.#...#.......#.#...#...#.....#.#.#.#...#.#.#.#...........#....f#.......#.P.#...#\n#.#.#.#########.#.#####.#.#####.#.#.#.###.#.#.#.#######.###########.#####.#####.#\n#.Y.#.......#...#.....#.#...#...#.#.#...#.#.#...#.#...#.#.....#...#...#...#...#.#\n#.#########.#.#####.###.###.#.###.#.###.#.#.#####.#.#.###.###.#.#.#####.###.###.#\n#.#...#.....#.#.....#...#...#...#.#...#.#.#.#.....#.#.....#...#.#.......#...#...#\n#.#.#.#.#####.#.#####.###.#.###.#####.#.#.#.#.###.#.#######.###N#########.###.###\n#...#.#.#...#.#.....#...#.#...#.....#.#.#.#...#...#...#.....#...#.#.........#...#\n#####.#.#.#.#.#########.#.###.#####.#.#.#.#####.#####.#.###.#.###.#.#######.###.#\n#...#.#...#.#.............#.....#...#...#.#...#...#...#...#.#.#...#...#...#..z#.#\n#K###.#####.#.###################.#####.#.#.#.###.#.#####.#.#.#.#.###.#.#.#.#.#.#\n#.....#...#.#.#.....#.....#.....#.....#.#.#.#...#.#...#...#.#b#.#...#...#.#.#.#.#\n#####.#.###.#.#####.#####.#.###.#####.#.#.#.###.###.###.###.#######.#####.#.###.#\n#...#.#.#...#...#.......#...#.#.....#.#.#...#.#.#...#...#.........#...#...#.....#\n#.#.#.#.#.#####.#.#####.#####.#####.#.#.#.###.#.#.###.###########.#.#.#.#########\n#.#.#...#.#...#...#...#...#.#...#...#...#.#.A.#.....#.....#..k..#.#.#.#.#.......#\n#.#.#####.###.#####.#####.#.#.#.#.###.###.###.#######.###.#####.#.#.###.#.#######\n#.#.......#.......#.....#.#...#.#...#...#.......#...#.#.#.....#...#.#...#.......#\n#X#########.#####.#.###.#.#####.###.#####.#######.#.#.#.#####.#.###.#.###.#####.#\n#.....#.......#...#.#.#.#...#.....#.....#.#.......#.#...#.....#...#.#...#.....#.#\n#####.#.#####.#.###.#.#.###.#.#########.###.#######.###.#.#######.#.###.#.#####.#\n#.....#...#...#...#.#.#.....#.#...#.....#...#.....#.#...#.#.#.....#...#.#.#...#.#\n#.#######.#.#######.#.#######.#.#.#.#####.#####.###.#####.#.#.#####.#.#.###.#.#.#\n#.......#.#.............#.....#.#...#...#.....#.......#...#...#.....#.#.....#.#.#\n#.#####.###############.#.###.#.#####.#.#.###.#######.#.###.#######.#.#######.#.#\n#.#.....#...T.....#...#.#.#...#.....#.#.#...#.......#...#......c....#.......#...#\n###.###.#.#######.#H#.#.#.#.#######.#.#####.#######.#####.#####.###############.#\n#...#...#.#.#.....#.#.#...#...#.....#...#...#.E...#...#...#...#.#.......#.......#\n#.#######.#.#.#####.#.#########.#######.#.###.###.###.#####.#.###.#####.#.#######\n#.....L.....#.......#.............G..i..#.....#.....#.......#.........#.........#\n#################################################################################")

(def key? (->> u/letters (map str) set))
(def door? (->> u/letters str/upper-case (map str) set))

(defn prune [m]
  ;(prn ::prune)
  (let [{:keys [::XYS ::KEYS ::DOORS ::start-xys]} m
        no-deadends (fn [[XYS NEI] xy]
                      (blet [nei  (->> xy u/neighbours (filter XYS))
                             NEI+ (assoc NEI xy nei)
                             XYS- (disj XYS xy)]
                        (cond
                          (contains? KEYS xy), [XYS NEI+]
                          (contains? DOORS xy) [XYS NEI+]
                          (#{start-xys} xy),,, [XYS NEI+]
                          (-> nei count (= 1)) [XYS- NEI]
                          :else,,,,,,,,,,,,,,, [XYS NEI+])))
        [xys- nei] (reduce no-deadends [XYS {}] XYS)]
    (assoc m ::XYS xys- ::NEIGHS nei)))


(defn parse [ss]
  (loop [todo (map str ss)
         x    0
         y    0
         m    {::XYS #{} ::KEYS {} ::DOORS {}}]
    (blet [todo- (rest todo)
           a     (first todo)
           x+    (inc x)
           y+    (inc y)
           m+    (update m ::XYS conj [x y])
           md    (update m+ ::DOORS assoc [x y] a)
           mk    (update m+ ::KEYS assoc [x y] a)
           ms    (assoc m+ ::start-xys {[x y] a})
           done  (->> m (iterate prune) u/fixed-point)]
      (cond
        (empty? todo) done
        (= a "#"),,,, (recur todo- x+ y m)
        (= a "."),,,, (recur todo- x+ y m+)
        (door? a),,,, (recur todo- x+ y md)
        (key? a),,,,, (recur todo- x+ y mk)
        (= a "@"),,,, (recur todo- x+ y ms)
        (= a "\n"),,, (recur todo- 0 y+ m)))))

(defn patch [MAP]
  (let [{:keys [::start-xys]} MAP
        [x y] (-> start-xys first key)
        starts {[(dec x) (dec y)] "1"
                [(inc x) (dec y)] "2"
                [(dec x) (inc y)] "3"
                [(inc x) (inc y)] "4"}
        walls (into #{[x y]} (u/neighbours [x y]))]
    (-> MAP
      (assoc ::start-xys starts)
      (update ::XYS set/difference walls)
      (update ::NEIGHS #(reduce-kv (fn [m k v] (assoc m k (remove walls v))) {} %)))))


(defn draw [m]
  (let [{:keys [::XYS ::KEYS ::DOORS ::start-xys]} m
        floor (zipmap XYS (repeat \.))
        MAP (merge floor KEYS DOORS start-xys)]
    (println (u/draw identity MAP \space))))



(defn key-to-key [m from-xy to-xy]
  (let [{:keys [::XYS ::DOORS ::KEYS ::NEIGHS]} m]
    (loop [paths     [[0 from-xy #{} #{}]]
           distances {}] ;;doors lenth
      (blet [paths-     (rest paths)
             path       (first paths)
             [steps xy doors been] path
             done?      (empty? paths)
             end?       (-> xy (= to-xy))
             D          (DOORS xy)
             been+      (conj been xy)
             steps+     (inc steps)
             doors*     (if D (conj doors (str/lower-case D)) doors)
             next-xy    (fn [xy]
                          (when-not (been+ xy)
                            [steps+ xy doors* been+]))
             path+      (->> xy NEIGHS (keep next-xy))
             paths+     (into paths- path+)
             distances+ (update distances doors (fnil min ##Inf) steps)
             slow?      (<= (distances doors ##Inf) steps)]
        (cond
          done? distances
          slow? (recur paths- distances)
          end?, (recur paths- distances+)
          :else (recur paths+ distances))))))



(defn graph [MAP]
  (let [{:keys [::XYS ::DOORS ::KEYS ::NEIGHS ::start-xys]} MAP
        start-xys (-> KEYS keys (concat (keys start-xys)))
        end-xys   (-> KEYS keys)
        rf        (fn rf [m start-xy]
                    (let [start-k (or (KEYS start-xy) ((MAP ::start-xys) start-xy))]
                      (assoc m start-k
                               (into {}
                                 (for [end-xy end-xys
                                       :when (not= start-xy end-xy)]
                                   (let [end-k (KEYS end-xy)
                                         dist  (or (get-in m [end-k start-k])
                                                   (key-to-key MAP start-xy end-xy))]
                                     [end-k dist]))))))]
    (reduce rf {} start-xys)))

#_(-> test1 parse draw)
#_(-> test1 parse)
#_(-> test1 parse (key-to-key [6 3] [22 3]))
#_(-> test1 parse graph)


(defn p1 [ss]
  (let [M     (->> ss parse)
        g     (-> M graph)
        KEYS  (-> g keys set)
        start (fn [k] [0 k #{}])]
    (loop [paths    (->> M ::start-xys vals (map start))
           pewpew   {}
           shortest [##Inf]]
      (blet [paths-    (rest paths)
             path      (first paths)
             [steps k have] path
             have+     (conj have k)
             next-ks   (fn [[to m]]
                         (when-not (have+ to)
                           (let [kf (fn [[doors st]]
                                      (when (every? have+ doors)
                                        [(+ st steps) to have+]))]
                             (keep kf m))))
             path+     (->> k g (mapcat next-ks) (remove nil?))
             paths+    (into paths- path+)
             too-long  (<= (first shortest) steps)
             too-slow  (<= (pewpew [have k] ##Inf) steps)
             pewpew+   (assoc pewpew [have k] steps)]
        (cond
          (empty? paths) shortest
          too-long,,,,,, (recur paths- pewpew shortest)
          too-slow,,,,,, (recur paths- pewpew shortest)
          (= KEYS have+) (recur paths- pewpew+ path)
          :else,,,,,,,,, (recur paths+ pewpew+ shortest))))))


#_(-> test1 parse draw)
#_(-> test1 parse graph)

#_(-> input parse draw)
#_(-> test2 parse graph)
#_(-> test2 parse draw)
#_(-> input parse patch #_graph)
;(-> input p1 time)


#_#_#_#_#_
(time (assert (-> test0 p1 first (= 86))))
(time (assert (-> test1 p1 first (= 132))))
(time (assert (-> test2 p1 first (= 136))))
(time (assert (-> test3 p1 first (= 81))))
(time (assert (-> input p1 first (= 7430))))

(defn p2 [ss]
  (let [M     (->> ss parse patch)
        g     (-> M graph)
        KEYS  (-> g keys set)]
    (loop [paths    [[0 #{} (-> M ::start-xys vals vec)]]
           pewpew   {}
           shortest [##Inf]]
      (blet [paths-    (rest paths)
             path      (first paths)
             [steps have ks k] path
             have+     (into have ks)
             next-ks   (fn [idx [to m]]
                         (when-not (have+ to)
                           (let [kf (fn [[doors st]]
                                      (when (every? have+ doors)
                                        [(+ st steps) have+ (assoc ks idx to) k]))]
                             (keep kf m))))
             fpath+    (fn [idx k] (->> k g (mapcat (partial next-ks idx)) (remove nil?)))
             path++    (map-indexed fpath+ ks)
             paths+    (reduce into paths- path++)
             too-long  (<= (first shortest) steps)
             too-slow  (<= (pewpew [have k] ##Inf) steps)
             pewpew+   (assoc pewpew [have k] steps)]
        (cond
          (empty? paths) shortest
          too-long,,,,,, (recur paths- pewpew shortest)
          too-slow,,,,,, (recur paths- pewpew shortest)
          (= KEYS have+) (recur paths- pewpew+ path)
          :else,,,,,,,,, (recur paths+ pewpew+ shortest))))))

(time (assert (= 1864 (first (p2 input)))))