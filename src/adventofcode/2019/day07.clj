(ns adventofcode.2019.day07
  (:require
    [clojure.math.combinatorics :as combo]
    [adventofcode.2019.day05 :as d5 :refer [parse step]]))

(def input "3,8,1001,8,10,8,105,1,0,0,21,38,55,68,93,118,199,280,361,442,99999,3,9,1002,9,2,9,101,5,9,9,102,4,9,9,4,9,99,3,9,101,3,9,9,1002,9,3,9,1001,9,4,9,4,9,99,3,9,101,4,9,9,102,3,9,9,4,9,99,3,9,102,2,9,9,101,4,9,9,102,2,9,9,1001,9,4,9,102,4,9,9,4,9,99,3,9,1002,9,2,9,1001,9,2,9,1002,9,5,9,1001,9,2,9,1002,9,4,9,4,9,99,3,9,101,1,9,9,4,9,3,9,102,2,9,9,4,9,3,9,101,1,9,9,4,9,3,9,101,1,9,9,4,9,3,9,101,1,9,9,4,9,3,9,101,2,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,102,2,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,1002,9,2,9,4,9,99,3,9,1001,9,1,9,4,9,3,9,1001,9,2,9,4,9,3,9,1002,9,2,9,4,9,3,9,101,2,9,9,4,9,3,9,1001,9,2,9,4,9,3,9,1001,9,1,9,4,9,3,9,102,2,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,1002,9,2,9,4,9,3,9,102,2,9,9,4,9,99,3,9,1002,9,2,9,4,9,3,9,1001,9,1,9,4,9,3,9,102,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,101,1,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,101,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,101,2,9,9,4,9,3,9,1001,9,2,9,4,9,99,3,9,1001,9,2,9,4,9,3,9,1001,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,101,1,9,9,4,9,3,9,1002,9,2,9,4,9,3,9,1002,9,2,9,4,9,3,9,1001,9,2,9,4,9,3,9,1001,9,2,9,4,9,3,9,101,1,9,9,4,9,3,9,1001,9,1,9,4,9,99,3,9,102,2,9,9,4,9,3,9,1001,9,1,9,4,9,3,9,1001,9,1,9,4,9,3,9,1002,9,2,9,4,9,3,9,1002,9,2,9,4,9,3,9,1001,9,2,9,4,9,3,9,1002,9,2,9,4,9,3,9,102,2,9,9,4,9,3,9,102,2,9,9,4,9,3,9,101,2,9,9,4,9,99")

(defn init-amps [phases instructions]
  (loop [[phase & todo] phases
         input 0
         amps []]
    (if (nil? phase)
      amps
      (let [amp (step {::d5/id phase ::d5/state instructions ::d5/idx 0 ::d5/input [phase input]})]
        (recur todo (::d5/output amp) (conj amps amp))))))


(defn linear-mode [phases instructions]
  (-> phases (init-amps instructions) peek ::d5/output))

(assert (= 43210 (linear-mode [4,3,2,1,0] (parse "3,15,3,16,1002,16,10,16,1,16,15,15,4,15,99,0,0"))))


(defn loop-mode [phases instructions]
  (let [amps (init-amps phases instructions)]
    (loop [amps   amps
           done   []
           input  (-> amps peek ::d5/output)
           exit   nil]
      (if (empty? amps)
        (recur done [] input input) ;; new loop
        (let [x (-> amps first (assoc ::d5/input [input]) step)]
          ;(prn x input)
          (if (= ::d5/halt x)
            exit
            (recur (rest amps) (conj done x) (::d5/output x) exit)))))))

(assert (= 139629729
          (loop-mode [9,8,7,6,5] (parse "3,26,1001,26,-4,26,3,27,1002,27,2,27,1,27,26,27,4,27,1001,28,-1,28,1005,28,6,99,0,0,5"))))
(assert (= 18216
          (loop-mode [9,7,8,5,6] (parse "3,52,1001,52,-5,52,3,53,1,52,56,54,1007,54,5,55,1005,55,26,1001,54,-5,54,1105,1,12,1,53,54,53,1008,54,0,55,1001,55,1,55,2,53,55,53,4,53,1001,56,-1,56,1005,56,6,99,0,0,0,0,10"))))


(defn f [mode phases input]
  (let [instructions (parse input)]
    (->> phases
      (combo/permutations)
      (map #(mode % instructions))
      (reduce max))))

(assert (= 277328 (f linear-mode (range 5) input)))


(f loop-mode (range 5 10) input)
;(assert (< 8149794 ,,,))
